CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE users (
  id UUID PRIMARY KEY NOT NULL DEFAULT uuid_generate_v4(),
  email VARCHAR(255) NOT NULL UNIQUE,
  username VARCHAR(255) NOT NULL UNIQUE,
  fullname VARCHAR(255) NOT NULL,
  password VARCHAR(255) NOT NULL,
  role user_role NOT NULL DEFAULT 'Patient',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  is_deleted BOOLEAN NOT NULL DEFAULT FALSE
);

CREATE TABLE patients (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL UNIQUE REFERENCES users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE doctors (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL UNIQUE REFERENCES users(id),
  doctor_url VARCHAR(255) NOT NULL UNIQUE,
  title VARCHAR(255),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE patient_doctor(
  patient_id INT NOT NULL REFERENCES patients(id),
  doctor_id INT NOT NULL REFERENCES doctors(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (patient_id, doctor_id)
);

CREATE INDEX idx_doctor ON patient_doctor(doctor_id);
CREATE INDEX idx_patient ON patient_doctor(patient_id);

CREATE TABLE user_info (
  user_id UUID PRIMARY KEY NOT NULL UNIQUE REFERENCES users(id),
  profile_image VARCHAR(255),
  address VARCHAR(255),
  city VARCHAR(100),
  state VARCHAR(100),
  country VARCHAR(100),
  zip VARCHAR(20),
  phone VARCHAR(20),
  date_of_birth DATE
);


CREATE TABLE operations(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE,
  description TEXT
);

CREATE TABLE service_types(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE,
  description TEXT
);

CREATE TABLE services (
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  patient_id INT NOT NULL REFERENCES patients(id),
  doctor_id INT NOT NULL REFERENCES doctors(id),
  service_types_id INT NOT NULL REFERENCES service_types(id),
  status service_status NOT NULL DEFAULT 'Created',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE operation_types(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE,
  description TEXT,
  service_types_id INT NOT NULL REFERENCES service_types(id)
);

CREATE TABLE service_operations(
  service_id INT NOT NULL REFERENCES services(id),
  operation_id INT NOT NULL REFERENCES operations(id),
  PRIMARY KEY (service_id, operation_id)
);

CREATE TABLE doctor_service_types(
  doctor_id INT NOT NULL REFERENCES doctors(id),
  service_types_id INT NOT NULL REFERENCES service_types(id),
  PRIMARY KEY (doctor_id, service_types_id)
);

CREATE TABLE doctor_operation_types(
  doctor_id INT NOT NULL REFERENCES doctors(id),
  operation_type_id INT NOT NULL REFERENCES operation_types(id),
  PRIMARY KEY (doctor_id, operation_type_id)
);

CREATE TABLE appointments(
  id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  service_id INT NOT NULL REFERENCES services(id),
  appointment_time TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE FUNCTION create_info_table_for_user()
RETURNS TRIGGER AS $$
BEGIN
  
  INSERT INTO user_info (user_id)
  VALUES (NEW.id);

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_user_insert
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION create_info_table_for_user();


CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at BEFORE UPDATE
ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();